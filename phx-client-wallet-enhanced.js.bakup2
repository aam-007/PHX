// phxClientWallet.ui.js
// Formal PHX Client Wallet UI with Price Oracle
// npm install chalk@4 figlet ora@5 cli-table3
// NOTE: Use chalk v4 and ora v5 for CommonJS compatibility if needed.

const { ethers } = require("hardhat");
const readline = require("readline");

const chalk = require("chalk");
const figlet = require("figlet");
const ora = require("ora");
const Table = require("cli-table3");

const CONFIG = {
  PHX_TOKEN_ADDRESS: "0x6652bfFF72971c548Fb70247abEA69A45427dB50",
  NETWORK: "ganache"
};

class PHXPriceOracle {
  constructor(phxContract) {
    this.phx = phxContract;
    this.basePriceUSD = 100; // 1 PHX = 100 USD base peg
    this.transactionHistory = [];
    this.volume24h = 0;
    this.totalTransactions = 0;
    this.totalVolume = 0;
  }

  async initialize() {
    await this.loadTransactionHistory();
    this.calculateMetrics();
  }

  async loadTransactionHistory() {
    try {
      const filter = this.phx.filters.Transfer();
      const events = await this.phx.queryFilter(filter, 0, "latest");
      
      this.transactionHistory = events.map(event => ({
        value: event.args.value || event.args[2],
        blockNumber: event.blockNumber,
        timestamp: Date.now() // In real implementation, would get from block
      }));

      this.totalTransactions = this.transactionHistory.length;
    } catch (error) {
      console.error("Error loading transaction history:", error);
    }
  }

  calculateMetrics() {
    // Calculate 24h volume (simulated - in real implementation would use actual timestamps)
    this.volume24h = this.transactionHistory
      .slice(-100) // Last 100 transactions as "24h volume"
      .reduce((sum, tx) => sum + parseFloat(ethers.formatUnits(tx.value, 18)), 0);

    // Calculate total volume
    this.totalVolume = this.transactionHistory
      .reduce((sum, tx) => sum + parseFloat(ethers.formatUnits(tx.value, 18)), 0);
  }

  calculateCurrentPrice() {
    // Price algorithm based on transaction activity
    const basePrice = this.basePriceUSD;
    
    // Factors affecting price
    const volumeFactor = Math.log10(this.volume24h + 1) * 2; // Logarithmic volume impact
    const transactionFactor = Math.log10(this.totalTransactions + 1) * 1.5; // Transaction count impact
    const networkHealth = Math.min(this.totalVolume / 10000, 2); // Network adoption factor
    
    // Calculate price with momentum
    let calculatedPrice = basePrice;
    
    // Apply volume momentum (higher volume = higher price)
    calculatedPrice *= (1 + (volumeFactor * 0.01));
    
    // Apply transaction momentum
    calculatedPrice *= (1 + (transactionFactor * 0.005));
    
    // Apply network health
    calculatedPrice *= (1 + (networkHealth * 0.01));

    // Add some random market fluctuation (±2%)
    const marketNoise = (Math.random() - 0.5) * 0.04;
    calculatedPrice *= (1 + marketNoise);

    // Ensure minimum price
    calculatedPrice = Math.max(calculatedPrice, basePrice * 0.5);
    
    return parseFloat(calculatedPrice.toFixed(2));
  }

  getMarketData() {
    const currentPrice = this.calculateCurrentPrice();
    
    return {
      price: currentPrice,
      volume24h: this.volume24h,
      totalTransactions: this.totalTransactions,
      totalVolume: this.totalVolume,
      priceChange: ((currentPrice - this.basePriceUSD) / this.basePriceUSD * 100).toFixed(2)
    };
  }

  convertToUSD(phxAmount) {
    const marketData = this.getMarketData();
    return parseFloat((phxAmount * marketData.price).toFixed(2));
  }

  convertToPHX(usdAmount) {
    const marketData = this.getMarketData();
    return parseFloat((usdAmount / marketData.price).toFixed(6));
  }
}

class PHXClientWallet {
  constructor() {
    this.phx = null;
    this.priceOracle = null;
    this.availableAccounts = [];
    this.userAccounts = [];
    this.currentUser = null;
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    // color theme (formal)
    this.theme = {
      title: chalk.blueBright,
      section: chalk.cyanBright,
      label: chalk.yellow,
      value: chalk.white,
      ok: chalk.greenBright,
      warn: chalk.yellowBright,
      err: chalk.redBright,
      dim: chalk.gray
    };
  }

  // ---------- UI helpers ----------
  fancyTitle(text) {
    try {
      const fig = figlet.textSync(text, { font: "Small", horizontalLayout: "fitted" });
      console.log(this.theme.title(fig));
    } catch (e) {
      console.log(this.theme.title(`\n${text}\n`));
    }
  }

  section(title) {
    const border = "─".repeat(58);
    console.log("\n" + this.theme.title("┌" + border + "┐"));
    console.log(this.theme.title("│") + " " + this.theme.section.bold(title.padEnd(56)) + this.theme.title("│"));
    console.log(this.theme.title("└" + border + "┘") + "\n");
  }

  smallNote(msg) { console.log(this.theme.dim(`\n${msg}\n`)); }
  error(msg) { console.log(this.theme.err(`\nERROR: ${msg}\n`)); }
  success(msg) { console.log(this.theme.ok(`\n${msg}\n`)); }

  // ---------- initialization ----------
  async initialize() {
    console.clear();
    this.fancyTitle("PHX WALLET");
    console.log(this.theme.dim("=".repeat(64)));
    console.log(this.theme.value("Starting PHX Client Wallet"));
    console.log(this.theme.warn("Ensure Ganache/Hardhat is running at http://127.0.0.1:7545"));
    console.log(this.theme.err("Treasury account is restricted to Central Bank Console"));
    console.log(this.theme.dim("=".repeat(64) + "\n"));

    const spinner = ora("Connecting to local node and loading accounts...").start();
    try {
      this.availableAccounts = await ethers.getSigners();
      if (!this.availableAccounts || this.availableAccounts.length === 0) {
        spinner.fail("No signers available");
        this.error("No local accounts available from ethers.getSigners()");
        return false;
      }

      // exclude treasury (index 0)
      this.userAccounts = this.availableAccounts.slice(1);
      spinner.succeed("Accounts loaded");

      const PHX = await ethers.getContractFactory("PhonexCoin");
      this.phx = await PHX.attach(CONFIG.PHX_TOKEN_ADDRESS);

      // Initialize price oracle
      spinner.text = "Initializing price oracle...";
      this.priceOracle = new PHXPriceOracle(this.phx);
      await this.priceOracle.initialize();

      this.success("Client Wallet connected successfully");
      console.log(this.theme.label("PHX Token Address: ") + this.theme.value(CONFIG.PHX_TOKEN_ADDRESS));
      
      const marketData = this.priceOracle.getMarketData();
      console.log(this.theme.label("Current PHX Price: ") + this.theme.ok(`$${marketData.price} USD`));
      console.log(this.theme.label("Base Peg: ") + this.theme.value("1 PHX = $100 USD"));
      
      this.smallNote("Treasury account hidden for security");

      await this.selectUser();
      return true;
    } catch (error) {
      spinner.fail("Initialization failed");
      this.error(error?.message || String(error));
      return false;
    }
  }

  // ---------- input helpers ----------
  question(prompt) {
    return new Promise((resolve) => { this.rl.question(prompt, resolve); });
  }

  async getAddressFromUser(prompt) {
    while (true) {
      const input = (await this.question(prompt)).trim();

      // numeric index
      if (input !== "" && !isNaN(input)) {
        const idx = parseInt(input);
        if (idx >= 0 && idx < this.userAccounts.length) {
          return this.userAccounts[idx].address;
        }
      }

      // address string
      try {
        if (ethers.isAddress(input)) {
          const treasuryAddress = this.availableAccounts[0].address.toLowerCase();
          if (input.toLowerCase() === treasuryAddress) {
            this.error("Treasury account cannot be accessed.");
            continue;
          }
          return input;
        }
      } catch (e) {
        // ignore
      }

      this.error(`Invalid address/index. Valid index: 0-${this.userAccounts.length - 1}.`);
    }
  }

  async getAmountFromUser(prompt) {
    while (true) {
      const input = (await this.question(prompt)).trim();
      const val = parseFloat(input);
      if (!isNaN(val) && val > 0) return input;
      this.error("Invalid amount. Enter a positive number.");
    }
  }

  // ---------- account selection ----------
  async selectUser() {
    this.section("SELECT CURRENT USER ACCOUNT");

    try {
      const marketData = this.priceOracle.getMarketData();

      const table = new Table({
        head: [this.theme.section("Idx"), this.theme.section("Address"), this.theme.section("Balance (PHX)"), this.theme.section("USD Value")],
        colWidths: [6, 42, 15, 15]
      });

      for (let i = 0; i < this.userAccounts.length; i++) {
        const addr = this.userAccounts[i].address;
        const bal = await this.phx.balanceOf(addr);
        const phxBalance = parseFloat(ethers.formatUnits(bal, 18));
        const usdValue = this.priceOracle.convertToUSD(phxBalance);
        
        table.push([
          this.theme.value(i.toString()), 
          this.theme.value(addr), 
          this.theme.ok(phxBalance.toFixed(2)), 
          this.theme.ok(`$${usdValue.toFixed(2)}`)
        ]);
      }

      console.log(table.toString());

      while (true) {
        const choice = await this.question(this.theme.warn(`\nSelect account index (0-${this.userAccounts.length - 1}): `));
        const index = parseInt(choice);
        if (!isNaN(index) && index >= 0 && index < this.userAccounts.length) {
          this.currentUser = this.userAccounts[index];
          const balance = await this.phx.balanceOf(this.currentUser.address);
          const phxBalance = parseFloat(ethers.formatUnits(balance, 18));
          const usdValue = this.priceOracle.convertToUSD(phxBalance);
          this.success(`Selected account ${index} | Balance: ${phxBalance.toFixed(2)} PHX ($${usdValue.toFixed(2)} USD)`);
          break;
        }
        this.error("Invalid index.");
      }
    } catch (error) {
      this.error("Account selection failed: " + (error?.message || String(error)));
      throw error;
    }
  }

  // ---------- operations ----------
  async checkMyBalance() {
    this.section("MY BALANCE");
    try {
      const balance = await this.phx.balanceOf(this.currentUser.address);
      const phxBalance = parseFloat(ethers.formatUnits(balance, 18));
      const usdValue = this.priceOracle.convertToUSD(phxBalance);
      const marketData = this.priceOracle.getMarketData();

      console.log(this.theme.label("Address: ") + this.theme.value(this.currentUser.address));
      console.log(this.theme.label("Balance: ") + this.theme.ok(`${phxBalance.toFixed(2)} PHX`));
      console.log(this.theme.label("USD Value: ") + this.theme.ok(`$${usdValue.toFixed(2)}`));
      console.log(this.theme.dim(`Current PHX Price: $${marketData.price} USD`));
    } catch (error) {
      this.error(error?.message || String(error));
    }
  }

  async checkAddressBalance() {
    this.section("CHECK ADDRESS BALANCE");

    try {
      // Display available accounts first
      const marketData = this.priceOracle.getMarketData();

      const table = new Table({
        head: [this.theme.section("Idx"), this.theme.section("Address"), this.theme.section("Balance (PHX)"), this.theme.section("USD Value")],
        colWidths: [6, 42, 15, 15]
      });

      for (let i = 0; i < this.userAccounts.length; i++) {
        const addr = this.userAccounts[i].address;
        const bal = await this.phx.balanceOf(addr);
        const phxBalance = parseFloat(ethers.formatUnits(bal, 18));
        const usdValue = this.priceOracle.convertToUSD(phxBalance);
        
        table.push([
          this.theme.value(i.toString()), 
          this.theme.value(addr), 
          this.theme.ok(phxBalance.toFixed(2)), 
          this.theme.ok(`$${usdValue.toFixed(2)}`)
        ]);
      }

      console.log(table.toString());
      console.log(this.theme.dim("\nAvailable wallet addresses listed above"));
      console.log(this.theme.dim("You can also enter any valid Ethereum address"));
      console.log(this.theme.dim(`Current PHX Price: $${marketData.price} USD`));

      // Get address input
      const address = await this.getAddressFromUser("Enter address or index: ");
      const balance = await this.phx.balanceOf(address);
      const phxBalance = parseFloat(ethers.formatUnits(balance, 18));
      const usdValue = this.priceOracle.convertToUSD(phxBalance);

      // Display result
      this.section("BALANCE CHECK RESULT");
      console.log(this.theme.label("Address: ") + this.theme.value(address));
      console.log(this.theme.label("Balance: ") + this.theme.ok(`${phxBalance.toFixed(2)} PHX`));
      console.log(this.theme.label("USD Value: ") + this.theme.ok(`$${usdValue.toFixed(2)}`));
      console.log(this.theme.dim(`Current PHX Price: $${marketData.price} USD`));
      
    } catch (error) {
      this.error(error?.message || String(error));
    }
  }

  // ---------- transfer ----------
  async transferToUser() {
    this.section("TRANSFER PHX");

    try {
      let recipient;
      while (true) {
        console.log(this.theme.section("\nRecipient Options:"));
        console.log(this.theme.value(" 1. Enter address or index"));
        console.log(this.theme.value(" 2. View available accounts"));
        console.log(this.theme.value(" 3. Cancel transfer\n"));

        const opt = (await this.question(this.theme.warn("Select an option (1–3): "))).trim();

        if (opt === "1") {
          recipient = await this.getAddressFromUser("Enter recipient: ");
          break;
        } else if (opt === "2") {
          await this.viewAllBalances();
        } else if (opt === "3") {
          this.smallNote("Transfer cancelled.");
          return;
        } else {
          this.error("Invalid option.");
        }
      }

      const amountStr = await this.getAmountFromUser("Enter amount of PHX to transfer: ");
      const amountWei = ethers.parseUnits(amountStr, 18);
      const marketData = this.priceOracle.getMarketData();
      const usdValue = this.priceOracle.convertToUSD(parseFloat(amountStr));

      console.log(this.theme.dim("\nTransfer summary:"));
      console.log(this.theme.label(" From:     ") + this.theme.value(this.currentUser.address));
      console.log(this.theme.label(" To:       ") + this.theme.value(recipient));
      console.log(this.theme.label(" Amount:   ") + this.theme.value(`${amountStr} PHX`));
      console.log(this.theme.label(" USD Value: ") + this.theme.value(`$${usdValue.toFixed(2)}`));
      console.log(this.theme.label(" Fee:      ") + this.theme.value("0 PHX (No fees)"));
      console.log(this.theme.dim(` Current Price: $${marketData.price} USD/PHX`));

      const confirm = (await this.question(this.theme.warn("\nConfirm transfer? (y/n): "))).trim().toLowerCase();
      if (confirm !== "y" && confirm !== "yes") {
        this.smallNote("Transfer cancelled.");
        return;
      }

      const bal = await this.phx.balanceOf(this.currentUser.address);
      if (bal < amountWei) {
        this.error(`Insufficient balance. Available: ${ethers.formatUnits(bal, 18)} PHX`);
        return;
      }

      const spinner = ora("Submitting transaction...").start();
      const tx = await this.phx.connect(this.currentUser).transfer(recipient, amountWei);
      spinner.text = "Awaiting confirmation...";
      const receipt = await tx.wait();
      
      // Update price oracle with new transaction
      await this.priceOracle.initialize();
      
      spinner.succeed("Transfer complete.");

    } catch (error) {
      this.error("Transfer failed: " + (error?.message || String(error)));
    }
  }

  async switchUser() { await this.selectUser(); }

  async viewAllBalances() {
    this.section("ALL USER BALANCES (Treasury Hidden)");
    try {
      const marketData = this.priceOracle.getMarketData();

      const table = new Table({
        head: [this.theme.section("Idx"), this.theme.section("Address"), this.theme.section("Balance (PHX)"), this.theme.section("USD Value"), this.theme.section("Status")],
        colWidths: [6, 36, 15, 15, 10]
      });

      for (let i = 0; i < this.userAccounts.length; i++) {
        const addr = this.userAccounts[i].address;
        const bal = await this.phx.balanceOf(addr);
        const phxBalance = parseFloat(ethers.formatUnits(bal, 18));
        const usdValue = this.priceOracle.convertToUSD(phxBalance);
        const status = addr === this.currentUser.address ? this.theme.warn("ACTIVE") : "";
        
        table.push([
          this.theme.value(i.toString()), 
          this.theme.value(addr), 
          this.theme.ok(phxBalance.toFixed(2)), 
          this.theme.ok(`$${usdValue.toFixed(2)}`),
          status
        ]);
      }

      console.log(table.toString());
      console.log(this.theme.dim(`Current PHX Price: $${marketData.price} USD`));

      const treasuryBal = await this.phx.balanceOf(this.availableAccounts[0].address);
      const treasuryPHX = parseFloat(ethers.formatUnits(treasuryBal, 18));
      const treasuryUSD = this.priceOracle.convertToUSD(treasuryPHX);
      console.log(this.theme.dim(`\nTreasury Balance: ${treasuryPHX.toFixed(2)} PHX ($${treasuryUSD.toFixed(2)} USD) - Read-Only`));
    } catch (error) {
      this.error(error?.message || String(error));
    }
  }

  // ---------- transaction history (CURRENT USER ONLY, arrow UI) ----------
  async viewTransactionHistory() {
    this.section("MY TRANSACTION HISTORY (current user)");

    try {
      if (!this.currentUser || !this.currentUser.address) {
        this.error("No current user selected.");
        return;
      }

      const me = String(this.currentUser.address).toLowerCase();
      const contractAddress = this.phx.address ?? this.phx.target ?? this.phx._address;
      if (!contractAddress) {
        this.error("Cannot determine contract address.");
        return;
      }

      const provider = ethers.provider;
      if (!provider) {
        this.error("Provider missing.");
        return;
      }

      // Query Transfer events
      const filter = this.phx.filters.Transfer();
      const events = await this.phx.queryFilter(filter, 0, "latest");

      // Filter only relevant events
      const myEvents = [];
      for (const ev of events) {
        const from = String(ev.args.from || ev.args[0]).toLowerCase();
        const to = String(ev.args.to || ev.args[1]).toLowerCase();

        if (from !== me && to !== me) continue;

        const b = await provider.getBlock(ev.blockNumber);
        const ts = b ? b.timestamp : null;

        myEvents.push({
          txHash: ev.transactionHash,
          from,
          to,
          value: ev.args.value || ev.args[2],
          time: ts ? new Date(Number(ts) * 1000).toLocaleString() : "n/a",
          blockNumber: ev.blockNumber
        });
      }

      if (myEvents.length === 0) {
        this.smallNote("No transactions found for the current user.");
        return;
      }

      myEvents.sort((a, b) => Number(b.blockNumber) - Number(a.blockNumber));
      const marketData = this.priceOracle.getMarketData();

      for (const e of myEvents) {
        const shortHash = String(e.txHash).slice(0, 12) + "...";
        const fromShort = String(e.from).slice(0, 10) + (String(e.from).length > 10 ? "…" : "");
        const toShort = String(e.to).slice(0, 10) + (String(e.to).length > 10 ? "…" : "");
        const amount = parseFloat(ethers.formatUnits(e.value, 18));
        const usdValue = this.priceOracle.convertToUSD(amount);

        if (e.from === me) {
          console.log(this.theme.err(fromShort) + " " + this.theme.label("──────▶") + " " + this.theme.value(toShort));
          console.log(this.theme.label(" Amount: ") + this.theme.err(`-${amount.toFixed(2)} PHX`) + this.theme.dim(` ($${usdValue.toFixed(2)} USD)`));
        } else {
          console.log(this.theme.value(fromShort) + " " + this.theme.label("──────▶") + " " + this.theme.ok("YOU"));
          console.log(this.theme.label(" Amount: ") + this.theme.ok(`+${amount.toFixed(2)} PHX`) + this.theme.dim(` ($${usdValue.toFixed(2)} USD)`));
        }
        console.log(this.theme.label(" Time:   ") + this.theme.value(e.time));
        console.log(this.theme.label(" Tx:     ") + this.theme.value(shortHash));
        console.log(this.theme.dim("──────────────────────────────────────────────"));
      }

      console.log(this.theme.dim(`\nCurrent PHX Price: $${marketData.price} USD`));

    } catch (error) {
      this.error("Failed to load history: " + (error?.message || String(error)));
    }
  }

  // ---------- market data ----------
  async showMarketData() {
    this.section("PHX MARKET DATA");

    try {
      const marketData = this.priceOracle.getMarketData();

      console.log(this.theme.section("Current Price: ") + this.theme.value(`$${marketData.price} USD`));
      console.log(this.theme.section("Base Peg: ") + this.theme.value("1 PHX = $100 USD"));
      console.log(this.theme.section("Price Change: ") + 
        (marketData.priceChange >= 0 ? this.theme.ok(`+${marketData.priceChange}%`) : this.theme.err(`${marketData.priceChange}%`)));
      console.log(this.theme.section("24h Volume: ") + this.theme.value(`${marketData.volume24h.toFixed(2)} PHX`));
      console.log(this.theme.section("Total Transactions: ") + this.theme.value(marketData.totalTransactions.toString()));
      console.log(this.theme.section("Total Volume: ") + this.theme.value(`${marketData.totalVolume.toFixed(2)} PHX`));

      console.log(this.theme.dim("\nPrice factors: Transaction volume, network activity, market momentum"));
      console.log(this.theme.dim("Base peg maintained through algorithmic price stabilization"));
    } catch (error) {
      this.error(error?.message || String(error));
    }
  }

  // ---------- system info ----------
  async showSystemInfo() {
    this.section("PHX SYSTEM INFORMATION");

    try {
      const totalSupply = await this.phx.totalSupply();
      const treasuryBalance = await this.phx.balanceOf(this.availableAccounts[0].address);
      const circulating = totalSupply - treasuryBalance;
      const marketData = this.priceOracle.getMarketData();

      console.log(this.theme.section("Total Supply: ") + this.theme.value(ethers.formatUnits(totalSupply, 18) + " PHX"));
      console.log(this.theme.section("Treasury Reserve: ") + this.theme.value(ethers.formatUnits(treasuryBalance, 18) + " PHX"));
      console.log(this.theme.section("Circulating Supply: ") + this.theme.value(ethers.formatUnits(circulating, 18) + " PHX"));
      console.log(this.theme.section("Transfer Fee: ") + this.theme.value("0 PHX (No fees)"));
      console.log(this.theme.section("Current Price: ") + this.theme.value(`$${marketData.price} USD`));

      console.log(this.theme.dim("\nTreasury operations restricted to Central Bank Console."));
    } catch (error) {
      this.error(error?.message || String(error));
    }
  }

  // ---------- price converter ----------
  async showPriceConverter() {
    this.section("PHX PRICE CONVERTER");

    try {
      const marketData = this.priceOracle.getMarketData();

      console.log(this.theme.label("Current PHX Price: ") + this.theme.ok(`$${marketData.price} USD`));
      console.log(this.theme.label("Base Peg: ") + this.theme.value("1 PHX = $100 USD") + "\n");

      // PHX to USD conversion
      const phxAmount = await this.question(this.theme.warn("Enter PHX amount to convert to USD: "));
      const phxValue = parseFloat(phxAmount);
      if (!isNaN(phxValue) && phxValue > 0) {
        const usdValue = this.priceOracle.convertToUSD(phxValue);
        console.log(this.theme.ok(`\n${phxValue} PHX = $${usdValue.toFixed(2)} USD`));
      }

      console.log("");

      // USD to PHX conversion
      const usdAmount = await this.question(this.theme.warn("Enter USD amount to convert to PHX: "));
      const usdValue = parseFloat(usdAmount);
      if (!isNaN(usdValue) && usdValue > 0) {
        const phxValue = this.priceOracle.convertToPHX(usdValue);
        console.log(this.theme.ok(`\n$${usdValue.toFixed(2)} USD = ${phxValue.toFixed(6)} PHX`));
      }

    } catch (error) {
      this.error(error?.message || String(error));
    }
  }

  // ---------- main menu ----------
  async mainMenu() {
    while (true) {
      const marketData = this.priceOracle.getMarketData();
      const priceChangeColor = marketData.priceChange >= 0 ? this.theme.ok : this.theme.err;
      
      this.section("MAIN MENU");
      console.log(this.theme.section(`PHX Price: $${marketData.price} USD `) + 
                 priceChangeColor(`(${marketData.priceChange >= 0 ? '+' : ''}${marketData.priceChange}%)`));
      console.log("");
      console.log(this.theme.value(" 1. Check My Balance"));
      console.log(this.theme.value(" 2. Check Address Balance"));
      console.log(this.theme.value(" 3. Transfer PHX"));
      console.log(this.theme.value(" 4. View All Balances"));
      console.log(this.theme.value(" 5. View Transaction History"));
      console.log(this.theme.value(" 6. Show Market Data"));
      console.log(this.theme.value(" 7. Price Converter"));
      console.log(this.theme.value(" 8. Show System Info"));
      console.log(this.theme.value(" 9. Switch User"));
      console.log(this.theme.value("10. Exit\n"));

      const choice = (await this.question(this.theme.warn("Select option: "))).trim();

      if (choice === "1") await this.checkMyBalance();
      else if (choice === "2") await this.checkAddressBalance();
      else if (choice === "3") await this.transferToUser();
      else if (choice === "4") await this.viewAllBalances();
      else if (choice === "5") await this.viewTransactionHistory();
      else if (choice === "6") await this.showMarketData();
      else if (choice === "7") await this.showPriceConverter();
      else if (choice === "8") await this.showSystemInfo();
      else if (choice === "9") await this.switchUser();
      else if (choice === "10") {
        this.smallNote("Exiting wallet...");
        this.rl.close();
        process.exit(0);
      } else {
        this.error("Invalid selection.");
      }

      await this.question(this.theme.dim("\nPress Enter to continue..."));
    }
  }
}

// ---------- execution ----------
async function start() {
  const wallet = new PHXClientWallet();
  const ok = await wallet.initialize();
  if (ok) await wallet.mainMenu();
}
start();